{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/dalecottrell/Desktop/my-portfolio2.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/dalecottrell/Desktop/my-portfolio2.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/dalecottrell/Desktop/my-portfolio2.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Particle = void 0;\n\nvar ParticlesOptions_1 = require(\"../Options/Classes/Particles/ParticlesOptions\");\n\nvar Shape_1 = require(\"../Options/Classes/Particles/Shape/Shape\");\n\nvar Enums_1 = require(\"../Enums\");\n\nvar Utils_1 = require(\"../Utils\");\n\nvar Vector_1 = require(\"./Particle/Vector\");\n\nvar Vector3d_1 = require(\"./Particle/Vector3d\");\n\nvar Particle = /*#__PURE__*/function () {\n  function Particle(id, container, position, overrideOptions, group) {\n    _classCallCheck(this, Particle);\n\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n\n    this.id = id;\n    this.container = container;\n    this.group = group;\n    this.fill = true;\n    this.close = true;\n    this.lastPathTime = 0;\n    this.destroyed = false;\n    this.unbreakable = false;\n    this.splitCount = 0;\n    this.misplaced = false;\n    this.maxDistance = {};\n    var pxRatio = container.retina.pixelRatio;\n    var options = container.actualOptions;\n    var particlesOptions = new ParticlesOptions_1.ParticlesOptions();\n    particlesOptions.load(options.particles);\n    var shapeType = particlesOptions.shape.type;\n    var reduceDuplicates = particlesOptions.reduceDuplicates;\n    this.shape = shapeType instanceof Array ? Utils_1.itemFromArray(shapeType, this.id, reduceDuplicates) : shapeType;\n\n    if (overrideOptions === null || overrideOptions === void 0 ? void 0 : overrideOptions.shape) {\n      if (overrideOptions.shape.type) {\n        var overrideShapeType = overrideOptions.shape.type;\n        this.shape = overrideShapeType instanceof Array ? Utils_1.itemFromArray(overrideShapeType, this.id, reduceDuplicates) : overrideShapeType;\n      }\n\n      var shapeOptions = new Shape_1.Shape();\n      shapeOptions.load(overrideOptions.shape);\n\n      if (this.shape) {\n        this.shapeData = this.loadShapeData(shapeOptions, reduceDuplicates);\n      }\n    } else {\n      this.shapeData = this.loadShapeData(particlesOptions.shape, reduceDuplicates);\n    }\n\n    if (overrideOptions !== undefined) {\n      particlesOptions.load(overrideOptions);\n    }\n\n    if (((_a = this.shapeData) === null || _a === void 0 ? void 0 : _a.particles) !== undefined) {\n      particlesOptions.load((_b = this.shapeData) === null || _b === void 0 ? void 0 : _b.particles);\n    }\n\n    this.fill = (_d = (_c = this.shapeData) === null || _c === void 0 ? void 0 : _c.fill) !== null && _d !== void 0 ? _d : this.fill;\n    this.close = (_f = (_e = this.shapeData) === null || _e === void 0 ? void 0 : _e.close) !== null && _f !== void 0 ? _f : this.close;\n    this.options = particlesOptions;\n    var zIndexValue = Utils_1.getRangeValue(this.options.zIndex.value);\n    this.pathDelay = Utils_1.getValue(this.options.move.path.delay) * 1000;\n    this.wobbleDistance = 0;\n    container.retina.initParticle(this);\n    var sizeOptions = this.options.size;\n    var sizeValue = Utils_1.getValue(sizeOptions) * container.retina.pixelRatio;\n    var sizeRange = sizeOptions.value;\n    this.size = {\n      enable: sizeOptions.animation.enable,\n      value: sizeValue,\n      max: Utils_1.getRangeMax(sizeRange) * pxRatio,\n      min: Utils_1.getRangeMin(sizeRange) * pxRatio,\n      loops: 0,\n      maxLoops: sizeOptions.animation.count\n    };\n    var sizeAnimation = sizeOptions.animation;\n\n    if (sizeAnimation.enable) {\n      this.size.status = Enums_1.AnimationStatus.increasing;\n\n      switch (sizeAnimation.startValue) {\n        case Enums_1.StartValueType.min:\n          this.size.value = this.size.min;\n          this.size.status = Enums_1.AnimationStatus.increasing;\n          break;\n\n        case Enums_1.StartValueType.random:\n          this.size.value = Utils_1.randomInRange(this.size) * pxRatio;\n          this.size.status = Math.random() >= 0.5 ? Enums_1.AnimationStatus.increasing : Enums_1.AnimationStatus.decreasing;\n          break;\n\n        case Enums_1.StartValueType.max:\n        default:\n          this.size.value = this.size.max;\n          this.size.status = Enums_1.AnimationStatus.decreasing;\n          break;\n      }\n\n      this.size.velocity = ((_g = this.sizeAnimationSpeed) !== null && _g !== void 0 ? _g : container.retina.sizeAnimationSpeed) / 100 * container.retina.reduceFactor;\n\n      if (!sizeAnimation.sync) {\n        this.size.velocity *= Math.random();\n      }\n    }\n\n    this.direction = Utils_1.getParticleDirectionAngle(this.options.move.direction);\n    this.bubble = {\n      inRange: false\n    };\n    this.initialVelocity = this.calculateVelocity();\n    this.velocity = this.initialVelocity.copy();\n    var rotateOptions = this.options.rotate;\n    this.rotate = {\n      enable: rotateOptions.animation.enable,\n      value: Utils_1.getRangeValue(rotateOptions.value) * Math.PI / 180\n    };\n    var rotateDirection = rotateOptions.direction;\n\n    if (rotateDirection === Enums_1.RotateDirection.random) {\n      var index = Math.floor(Math.random() * 2);\n      rotateDirection = index > 0 ? Enums_1.RotateDirection.counterClockwise : Enums_1.RotateDirection.clockwise;\n    }\n\n    switch (rotateDirection) {\n      case Enums_1.RotateDirection.counterClockwise:\n      case \"counterClockwise\":\n        this.rotate.status = Enums_1.AnimationStatus.decreasing;\n        break;\n\n      case Enums_1.RotateDirection.clockwise:\n        this.rotate.status = Enums_1.AnimationStatus.increasing;\n        break;\n    }\n\n    var rotateAnimation = this.options.rotate.animation;\n\n    if (rotateAnimation.enable) {\n      this.rotate.velocity = rotateAnimation.speed / 360 * container.retina.reduceFactor;\n\n      if (!rotateAnimation.sync) {\n        this.rotate.velocity *= Math.random();\n      }\n    }\n\n    var tiltOptions = this.options.tilt;\n    this.tilt = {\n      enable: tiltOptions.enable,\n      value: Utils_1.getRangeValue(tiltOptions.value) * Math.PI / 180,\n      sinDirection: Math.random() >= 0.5 ? 1 : -1,\n      cosDirection: Math.random() >= 0.5 ? 1 : -1\n    };\n    var tiltDirection = tiltOptions.direction;\n\n    if (tiltDirection === Enums_1.TiltDirection.random) {\n      var _index = Math.floor(Math.random() * 2);\n\n      tiltDirection = _index > 0 ? Enums_1.TiltDirection.counterClockwise : Enums_1.TiltDirection.clockwise;\n    }\n\n    switch (tiltDirection) {\n      case Enums_1.TiltDirection.counterClockwise:\n      case \"counterClockwise\":\n        this.tilt.status = Enums_1.AnimationStatus.decreasing;\n        break;\n\n      case Enums_1.TiltDirection.clockwise:\n        this.tilt.status = Enums_1.AnimationStatus.increasing;\n        break;\n    }\n\n    var tiltAnimation = this.options.tilt.animation;\n\n    if (tiltAnimation.enable) {\n      this.tilt.velocity = tiltAnimation.speed / 360 * container.retina.reduceFactor;\n\n      if (!tiltAnimation.sync) {\n        this.tilt.velocity *= Math.random();\n      }\n    }\n\n    var orbitOptions = particlesOptions.orbit;\n\n    if (orbitOptions.enable) {\n      this.orbitRotation = Utils_1.getRangeValue(orbitOptions.rotation.value);\n      this.orbitColor = Utils_1.colorToHsl(orbitOptions.color);\n    }\n\n    var hslColor = Utils_1.colorToHsl(this.options.color, this.id, reduceDuplicates);\n\n    if (hslColor) {\n      this.color = Utils_1.getHslAnimationFromHsl(hslColor, this.options.color.animation, container.retina.reduceFactor);\n    }\n\n    var gradient = this.options.gradient instanceof Array ? Utils_1.itemFromArray(this.options.gradient) : this.options.gradient;\n\n    if (gradient) {\n      this.gradient = {\n        angle: {\n          value: gradient.angle.value,\n          enable: gradient.angle.animation.enable,\n          velocity: gradient.angle.animation.speed / 360 * container.retina.reduceFactor\n        },\n        type: gradient.type,\n        colors: []\n      };\n      var _rotateDirection = gradient.angle.direction;\n\n      if (_rotateDirection === Enums_1.RotateDirection.random) {\n        var _index2 = Math.floor(Math.random() * 2);\n\n        _rotateDirection = _index2 > 0 ? Enums_1.RotateDirection.counterClockwise : Enums_1.RotateDirection.clockwise;\n      }\n\n      switch (_rotateDirection) {\n        case Enums_1.RotateDirection.counterClockwise:\n        case \"counterClockwise\":\n          this.gradient.angle.status = Enums_1.AnimationStatus.decreasing;\n          break;\n\n        case Enums_1.RotateDirection.clockwise:\n          this.gradient.angle.status = Enums_1.AnimationStatus.increasing;\n          break;\n      }\n\n      var _iterator = _createForOfIteratorHelper(gradient.colors),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var grColor = _step.value;\n          var grHslColor = Utils_1.colorToHsl(grColor.value, this.id, reduceDuplicates);\n\n          if (grHslColor) {\n            var grHslAnimation = Utils_1.getHslAnimationFromHsl(grHslColor, grColor.value.animation, container.retina.reduceFactor);\n            var addColor = {\n              stop: grColor.stop,\n              value: grHslAnimation,\n              opacity: grColor.opacity ? {\n                enable: grColor.opacity.animation.enable,\n                max: Utils_1.getRangeMax(grColor.opacity.value),\n                min: Utils_1.getRangeMin(grColor.opacity.value),\n                status: Enums_1.AnimationStatus.increasing,\n                value: Utils_1.getRangeValue(grColor.opacity.value),\n                velocity: grColor.opacity.animation.speed / 100 * container.retina.reduceFactor\n              } : undefined\n            };\n\n            if (grColor.opacity && addColor.opacity) {\n              var opacityRange = grColor.opacity.value;\n              addColor.opacity.min = Utils_1.getRangeMin(opacityRange);\n              addColor.opacity.max = Utils_1.getRangeMax(opacityRange);\n              var _opacityAnimation = grColor.opacity.animation;\n\n              switch (_opacityAnimation.startValue) {\n                case Enums_1.StartValueType.min:\n                  addColor.opacity.value = addColor.opacity.min;\n                  addColor.opacity.status = Enums_1.AnimationStatus.increasing;\n                  break;\n\n                case Enums_1.StartValueType.random:\n                  addColor.opacity.value = Utils_1.randomInRange(addColor.opacity);\n                  addColor.opacity.status = Math.random() >= 0.5 ? Enums_1.AnimationStatus.increasing : Enums_1.AnimationStatus.decreasing;\n                  break;\n\n                case Enums_1.StartValueType.max:\n                default:\n                  addColor.opacity.value = addColor.opacity.max;\n                  addColor.opacity.status = Enums_1.AnimationStatus.decreasing;\n                  break;\n              }\n            }\n\n            this.gradient.colors.push(addColor);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n\n    var rollOpt = this.options.roll;\n\n    if (rollOpt.enable) {\n      if (this.color) {\n        if (rollOpt.backColor) {\n          this.backColor = Utils_1.colorToHsl(rollOpt.backColor);\n        } else if (rollOpt.darken.enable && rollOpt.enlighten.enable) {\n          this.alterType = Math.random() >= 0.5 ? Enums_1.AlterType.darken : Enums_1.AlterType.enlighten;\n          this.alterValue = this.alterType === Enums_1.AlterType.darken ? rollOpt.darken.value : rollOpt.enlighten.value;\n        } else if (rollOpt.darken.enable) {\n          this.alterType = Enums_1.AlterType.darken;\n          this.alterValue = rollOpt.darken.value;\n        } else if (rollOpt.enlighten.enable) {\n          this.alterType = Enums_1.AlterType.enlighten;\n          this.alterValue = rollOpt.enlighten.value;\n        }\n      }\n\n      this.rollAngle = Math.random() * Math.PI * 2;\n      this.rollSpeed = Utils_1.getRangeValue(rollOpt.speed) / 360;\n    } else {\n      this.rollAngle = 0;\n      this.rollSpeed = 0;\n    }\n\n    var wobbleOpt = this.options.wobble;\n\n    if (wobbleOpt.enable) {\n      this.wobbleAngle = Math.random() * Math.PI * 2;\n      this.wobbleSpeed = Utils_1.getRangeValue(wobbleOpt.speed) / 360;\n    } else {\n      this.wobbleAngle = 0;\n      this.wobbleSpeed = 0;\n    }\n\n    this.position = this.calcPosition(container, position, Utils_1.clamp(zIndexValue, 0, container.zLayers));\n    this.initialPosition = this.position.copy();\n    this.offset = Vector_1.Vector.origin;\n    var particles = container.particles;\n    particles.needsSort = particles.needsSort || particles.lastZIndex < this.position.z;\n    particles.lastZIndex = this.position.z;\n    this.zIndexFactor = this.position.z / container.zLayers;\n    var opacityOptions = this.options.opacity;\n    this.opacity = {\n      enable: opacityOptions.animation.enable,\n      max: Utils_1.getRangeMax(opacityOptions.value),\n      min: Utils_1.getRangeMin(opacityOptions.value),\n      value: Utils_1.getRangeValue(opacityOptions.value),\n      loops: 0,\n      maxLoops: opacityOptions.animation.count\n    };\n    var opacityAnimation = opacityOptions.animation;\n\n    if (opacityAnimation.enable) {\n      this.opacity.status = Enums_1.AnimationStatus.increasing;\n      var _opacityRange = opacityOptions.value;\n      this.opacity.min = Utils_1.getRangeMin(_opacityRange);\n      this.opacity.max = Utils_1.getRangeMax(_opacityRange);\n\n      switch (opacityAnimation.startValue) {\n        case Enums_1.StartValueType.min:\n          this.opacity.value = this.opacity.min;\n          this.opacity.status = Enums_1.AnimationStatus.increasing;\n          break;\n\n        case Enums_1.StartValueType.random:\n          this.opacity.value = Utils_1.randomInRange(this.opacity);\n          this.opacity.status = Math.random() >= 0.5 ? Enums_1.AnimationStatus.increasing : Enums_1.AnimationStatus.decreasing;\n          break;\n\n        case Enums_1.StartValueType.max:\n        default:\n          this.opacity.value = this.opacity.max;\n          this.opacity.status = Enums_1.AnimationStatus.decreasing;\n          break;\n      }\n\n      this.opacity.velocity = opacityAnimation.speed / 100 * container.retina.reduceFactor;\n\n      if (!opacityAnimation.sync) {\n        this.opacity.velocity *= Math.random();\n      }\n    }\n\n    this.sides = 24;\n    var drawer = container.drawers.get(this.shape);\n\n    if (!drawer) {\n      drawer = Utils_1.Plugins.getShapeDrawer(this.shape);\n\n      if (drawer) {\n        container.drawers.set(this.shape, drawer);\n      }\n    }\n\n    if (drawer === null || drawer === void 0 ? void 0 : drawer.loadShape) {\n      drawer === null || drawer === void 0 ? void 0 : drawer.loadShape(this);\n    }\n\n    var sideCountFunc = drawer === null || drawer === void 0 ? void 0 : drawer.getSidesCount;\n\n    if (sideCountFunc) {\n      this.sides = sideCountFunc(this);\n    }\n\n    this.stroke = this.options.stroke instanceof Array ? Utils_1.itemFromArray(this.options.stroke, this.id, reduceDuplicates) : this.options.stroke;\n    this.strokeWidth = this.stroke.width * container.retina.pixelRatio;\n    var strokeHslColor = (_h = Utils_1.colorToHsl(this.stroke.color)) !== null && _h !== void 0 ? _h : this.getFillColor();\n\n    if (strokeHslColor) {\n      this.strokeColor = Utils_1.getHslAnimationFromHsl(strokeHslColor, (_j = this.stroke.color) === null || _j === void 0 ? void 0 : _j.animation, container.retina.reduceFactor);\n    }\n\n    this.life = this.loadLife();\n    this.spawning = this.life.delay > 0;\n\n    if (this.options.move.spin.enable) {\n      var spinPos = (_k = this.options.move.spin.position) !== null && _k !== void 0 ? _k : {\n        x: 50,\n        y: 50\n      };\n      var spinCenter = {\n        x: spinPos.x / 100 * container.canvas.size.width,\n        y: spinPos.y / 100 * container.canvas.size.height\n      };\n      var pos = this.getPosition();\n      var distance = Utils_1.getDistance(pos, spinCenter);\n      this.spin = {\n        center: spinCenter,\n        direction: this.velocity.x >= 0 ? Enums_1.RotateDirection.clockwise : Enums_1.RotateDirection.counterClockwise,\n        angle: this.velocity.angle,\n        radius: distance,\n        acceleration: Utils_1.getRangeValue(this.options.move.spin.acceleration)\n      };\n    }\n\n    this.shadowColor = Utils_1.colorToRgb(this.options.shadow.color);\n\n    if (drawer && drawer.particleInit) {\n      drawer.particleInit(container, this);\n    }\n\n    var _iterator2 = _createForOfIteratorHelper(container.plugins),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _step2$value = _slicedToArray(_step2.value, 2),\n            plugin = _step2$value[1];\n\n        if (plugin.particleCreated) {\n          plugin.particleCreated(this);\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  _createClass(Particle, [{\n    key: \"isVisible\",\n    value: function isVisible() {\n      return !this.destroyed && !this.spawning && this.isInsideCanvas();\n    }\n  }, {\n    key: \"isInsideCanvas\",\n    value: function isInsideCanvas() {\n      var radius = this.getRadius();\n      var canvasSize = this.container.canvas.size;\n      return this.position.x >= -radius && this.position.y >= -radius && this.position.y <= canvasSize.height + radius && this.position.x <= canvasSize.width + radius;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(delta) {\n      var container = this.container;\n\n      var _iterator3 = _createForOfIteratorHelper(container.plugins),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _step3$value = _slicedToArray(_step3.value, 2),\n              plugin = _step3$value[1];\n\n          container.canvas.drawParticlePlugin(plugin, this, delta);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      container.canvas.drawParticle(this, delta);\n    }\n  }, {\n    key: \"getPosition\",\n    value: function getPosition() {\n      return {\n        x: this.position.x + this.offset.x,\n        y: this.position.y + this.offset.y,\n        z: this.position.z\n      };\n    }\n  }, {\n    key: \"getRadius\",\n    value: function getRadius() {\n      return this.bubble.radius || this.size.value;\n    }\n  }, {\n    key: \"getMass\",\n    value: function getMass() {\n      var radius = this.getRadius();\n      return Math.pow(radius, 2) * Math.PI / 2;\n    }\n  }, {\n    key: \"getFillColor\",\n    value: function getFillColor() {\n      if (this.bubble.color) {\n        return this.bubble.color;\n      }\n\n      var color = Utils_1.getHslFromAnimation(this.color);\n\n      if (color && (this.backColor || this.alterType && this.alterValue !== undefined)) {\n        var rolled = Math.floor(this.rollAngle / (Math.PI / 2)) % 2;\n\n        if (rolled) {\n          if (this.backColor) {\n            return this.backColor;\n          } else if (this.alterType && this.alterValue !== undefined) {\n            return {\n              h: color.h,\n              s: color.s,\n              l: color.l + (this.alterType === Enums_1.AlterType.darken ? -1 : 1) * this.alterValue\n            };\n          }\n        }\n      }\n\n      return color;\n    }\n  }, {\n    key: \"getStrokeColor\",\n    value: function getStrokeColor() {\n      var _a, _b;\n\n      return (_b = (_a = this.bubble.color) !== null && _a !== void 0 ? _a : Utils_1.getHslFromAnimation(this.strokeColor)) !== null && _b !== void 0 ? _b : this.getFillColor();\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(override) {\n      this.destroyed = true;\n      this.bubble.inRange = false;\n\n      if (this.unbreakable) {\n        return;\n      }\n\n      this.destroyed = true;\n      this.bubble.inRange = false;\n\n      var _iterator4 = _createForOfIteratorHelper(this.container.plugins),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _step4$value = _slicedToArray(_step4.value, 2),\n              plugin = _step4$value[1];\n\n          if (plugin.particleDestroyed) {\n            plugin.particleDestroyed(this, override);\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      if (override) {\n        return;\n      }\n\n      var destroyOptions = this.options.destroy;\n\n      if (destroyOptions.mode === Enums_1.DestroyMode.split) {\n        this.split();\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.opacity.loops = 0;\n      this.size.loops = 0;\n    }\n  }, {\n    key: \"split\",\n    value: function split() {\n      var splitOptions = this.options.destroy.split;\n\n      if (splitOptions.count >= 0 && this.splitCount++ > splitOptions.count) {\n        return;\n      }\n\n      var rate = Utils_1.getRangeValue(splitOptions.rate.value);\n\n      for (var i = 0; i < rate; i++) {\n        this.container.particles.addSplitParticle(this);\n      }\n    }\n  }, {\n    key: \"calcPosition\",\n    value: function calcPosition(container, position, zIndex) {\n      var tryCount = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n      var _a, _b, _c, _d, _e, _f;\n\n      var _iterator5 = _createForOfIteratorHelper(container.plugins),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _step5$value = _slicedToArray(_step5.value, 2),\n              plugin = _step5$value[1];\n\n          var pluginPos = plugin.particlePosition !== undefined ? plugin.particlePosition(position, this) : undefined;\n\n          if (pluginPos !== undefined) {\n            return Vector3d_1.Vector3d.create(pluginPos.x, pluginPos.y, zIndex);\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      var canvasSize = container.canvas.size;\n      var pos = Vector3d_1.Vector3d.create((_a = position === null || position === void 0 ? void 0 : position.x) !== null && _a !== void 0 ? _a : Math.random() * canvasSize.width, (_b = position === null || position === void 0 ? void 0 : position.y) !== null && _b !== void 0 ? _b : Math.random() * canvasSize.height, zIndex);\n      var radius = this.getRadius();\n      var outModes = this.options.move.outModes;\n\n      var fixHorizontal = function fixHorizontal(outMode) {\n        if (Utils_1.isInArray(outMode, Enums_1.OutMode.bounce) || Utils_1.isInArray(outMode, Enums_1.OutMode.bounceHorizontal)) {\n          if (pos.x > container.canvas.size.width - radius * 2) {\n            pos.x -= radius;\n          } else if (pos.x < radius * 2) {\n            pos.x += radius;\n          }\n        }\n      };\n\n      var fixVertical = function fixVertical(outMode) {\n        if (Utils_1.isInArray(outMode, Enums_1.OutMode.bounce) || Utils_1.isInArray(outMode, Enums_1.OutMode.bounceVertical)) {\n          if (pos.y > container.canvas.size.height - radius * 2) {\n            pos.y -= radius;\n          } else if (pos.y < radius * 2) {\n            pos.y += radius;\n          }\n        }\n      };\n\n      fixHorizontal((_c = outModes.left) !== null && _c !== void 0 ? _c : outModes.default);\n      fixHorizontal((_d = outModes.right) !== null && _d !== void 0 ? _d : outModes.default);\n      fixVertical((_e = outModes.top) !== null && _e !== void 0 ? _e : outModes.default);\n      fixVertical((_f = outModes.bottom) !== null && _f !== void 0 ? _f : outModes.default);\n\n      if (this.checkOverlap(pos, tryCount)) {\n        return this.calcPosition(container, undefined, zIndex, tryCount + 1);\n      }\n\n      return pos;\n    }\n  }, {\n    key: \"checkOverlap\",\n    value: function checkOverlap(pos) {\n      var tryCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var collisionsOptions = this.options.collisions;\n      var radius = this.getRadius();\n\n      if (!collisionsOptions.enable) {\n        return false;\n      }\n\n      var overlapOptions = collisionsOptions.overlap;\n\n      if (overlapOptions.enable) {\n        return false;\n      }\n\n      var retries = overlapOptions.retries;\n\n      if (retries >= 0 && tryCount > retries) {\n        throw new Error(\"Particle is overlapping and can't be placed\");\n      }\n\n      var overlaps = false;\n\n      var _iterator6 = _createForOfIteratorHelper(this.container.particles.array),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var particle = _step6.value;\n\n          if (Utils_1.getDistance(pos, particle.position) < radius + particle.getRadius()) {\n            overlaps = true;\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      return overlaps;\n    }\n  }, {\n    key: \"calculateVelocity\",\n    value: function calculateVelocity() {\n      var baseVelocity = Utils_1.getParticleBaseVelocity(this.direction);\n      var res = baseVelocity.copy();\n      var moveOptions = this.options.move;\n      var rad = Math.PI / 180 * moveOptions.angle.value;\n      var radOffset = Math.PI / 180 * moveOptions.angle.offset;\n      var range = {\n        left: radOffset - rad / 2,\n        right: radOffset + rad / 2\n      };\n\n      if (!moveOptions.straight) {\n        res.angle += Utils_1.randomInRange(Utils_1.setRangeValue(range.left, range.right));\n      }\n\n      if (moveOptions.random && typeof moveOptions.speed === \"number\") {\n        res.length *= Math.random();\n      }\n\n      return res;\n    }\n  }, {\n    key: \"loadShapeData\",\n    value: function loadShapeData(shapeOptions, reduceDuplicates) {\n      var shapeData = shapeOptions.options[this.shape];\n\n      if (shapeData) {\n        return Utils_1.deepExtend({}, shapeData instanceof Array ? Utils_1.itemFromArray(shapeData, this.id, reduceDuplicates) : shapeData);\n      }\n    }\n  }, {\n    key: \"loadLife\",\n    value: function loadLife() {\n      var container = this.container;\n      var particlesOptions = this.options;\n      var lifeOptions = particlesOptions.life;\n      var life = {\n        delay: container.retina.reduceFactor ? Utils_1.getRangeValue(lifeOptions.delay.value) * (lifeOptions.delay.sync ? 1 : Math.random()) / container.retina.reduceFactor * 1000 : 0,\n        delayTime: 0,\n        duration: container.retina.reduceFactor ? Utils_1.getRangeValue(lifeOptions.duration.value) * (lifeOptions.duration.sync ? 1 : Math.random()) / container.retina.reduceFactor * 1000 : 0,\n        time: 0,\n        count: particlesOptions.life.count\n      };\n\n      if (life.duration <= 0) {\n        life.duration = -1;\n      }\n\n      if (life.count <= 0) {\n        life.count = -1;\n      }\n\n      return life;\n    }\n  }]);\n\n  return Particle;\n}();\n\nexports.Particle = Particle;","map":null,"metadata":{},"sourceType":"script"}